//todo: implement player class
class Player
{
    static int gravity_direction;
    field int xpos, ypos, jump_height, dash_cooldown; // player's x and y position
    field boolean is_on_surface;

    /*
        * 1: down
        * 2: up
        * 3: right
        * 4: left
    */

    constructor Player new(int x, int y)
    {
        let xpos = x;
        let ypos = y;
        let gravity_direction = 1;
        let is_on_surface = true;
        let dash_cooldown = 0; //* Can use dash
        return this;
    }

    method int c_xpos_d() {
        return xpos;
    }

    method int c_ypos_d() {
        return ypos;
    }

    method void dispose()
    {
        do Memory.deAlloc(this);
        return;
    }

    method void update(int x, int y) {

        let xpos = x;
        let ypos = y;
        return;

    }

    method void set_jumping_height(int h) {
        let jump_height = h;
        return;
    }

    method boolean is_jumping() {
        return (jump_height>0);
    }

    ///// changed from method to function by rtamanyu /////////////////////
    function void set_gravity_direction(int dir) {

        if ( (dir < 5) & (dir > 0) ) {
            let gravity_direction = dir;
        }

        return;

    }

    function int get_gravity_direction() {
        return gravity_direction;
    }
    // I change it so that it can be used in other classes
    ///////////////////////////////////////////////////////////

    method void enforce_gravity() {

        var int looper;

        if (gravity_direction = 1) {

            let looper = 15 - ypos; //* How high is the player and drop him per 200 ms.

            if (looper > 0) {

                do draw(false);
                do update(xpos, ypos+1);
                do draw(true);

                do Sys.wait(20);

                let looper = 15 - ypos;

            }

        } else {
            if (gravity_direction = 2) {

                let looper = ypos; //* How high is the player and drop him per 200 ms.

                if (looper > 0) {

                    do draw(false);
                    do update(xpos, ypos-1);
                    do draw(true);

                    do Sys.wait(20);

                    let looper = ypos - 1;

                }
            
            } else {
                
                if (gravity_direction = 3) {

                    let looper = 31 - xpos; //* How high is the player and drop him per 200 ms.

                    if (looper > 0) {

                        do draw(false);
                        do update(xpos+1, ypos);
                        do draw(true);

                        do Sys.wait(20);

                        let looper = 31 - xpos;

                    }

                } else { //* Assumes 4 by default unless there is some fault in code

                    let looper = xpos; //* How high is the player and drop him per 200 ms.

                    if (looper > 0) {

                        do draw(false);
                        do update(xpos-1, ypos);
                        do draw(true);

                        do Sys.wait(20);

                        let looper = xpos - 1;

                    }

                }

            }
        }

        return;
    }


    method boolean on_ground() {

        var boolean result;

        if (gravity_direction = 1) {
            let result = (ypos = 15);  // Store comparison result
        } else {
            if (gravity_direction = 2) {
                let result = (ypos = 0);  // Store comparison result
            } else {
                if (gravity_direction = 3) {
                    let result = (xpos = 31);  // Store comparison result
                } else {
                    if (gravity_direction = 4) {
                        let result = (xpos = 0);  // Store comparison result
                    }
                }
            }
        }

        return result;

    }

    method void collision() { //* Invoked at every jump

        /*
            
            * Where do i get platform coords?

        */

        return;

    }

    method boolean has_surface() {

        if (on_ground()) {
            return true;
        } else {
            if (jump_height > 0) {
                return false;
            } else {
                //* Assumes collision system to handle everything!
                return is_on_surface;
            }
        }
        
    }

    method void stimulate_time() {

        /*

            * Game controller calls this function every time it loops.
            * Each loop has a delay of 50 ms.
            * 1000 ms = 1s.
            * So 20 loop rotations of game controller = 1 second irl.
            * So for 10 seconds cooldown, 10000 ms should become 0 in 200 rotation.
            * So each rotation should cut out 10000/200 => 100/2 => 50 ms.

        */

        if (dash_cooldown > 0) {
            let dash_cooldown = dash_cooldown - 50;
        }

        return; 

    }

    method void dash() {

        if (dash_cooldown = 0) {

            let dash_cooldown = 10000; //10 secs.

            do draw(false); //* remove player's current position
            
            if (gravity_direction = 1) {
                if (xpos+5 > 31) {let xpos = 19;}

                do update(xpos+5,ypos);
            } else {
                if (gravity_direction = 2) {

                    if (xpos+5 > 31) {let xpos = 19;}

                    do update(xpos+5,ypos);
                } else {
                    if (gravity_direction = 3) {
                        if (ypos-5 < 0) {let ypos = 19;}
                        do update(xpos,ypos-5);
                    } else {
                        if (gravity_direction = 4) {
                            if (ypos-5 < 0) {let ypos = 19;}
                            do update(xpos+5,ypos-5);
                        }
                    }
                }
            }

            do draw(true);

        }

        return;
        
    }

    method void jump() {

        if ((jump_height > 0) & is_on_surface) {

            /*

                * Clears current player
                * Updates location
                * Draws player at updated location

            */

            do draw(false);

            if (gravity_direction = 1) {
                do update(xpos, ypos-1); //* Update xpos and ypos.
            } else {
                if (gravity_direction = 2) {
                    do update(xpos, ypos+1); //* Update xpos and ypos.
                } else {
                    if (gravity_direction = 3) {
                        do update(xpos-1, ypos); //* Update xpos and ypos.
                    } else {
                        if (gravity_direction = 4) {
                            do update(xpos+1, ypos); //* Update xpos and ypos.
                        }
                    }
                }
            }

            do draw(true);

            do Sys.wait(20); //* Wait 1s before continuing. Adjust for animation
            let jump_height = jump_height - 1; //* Adjust 1 for smoother/rougher animation

        }

        //* Falling down will be handled by enforce gravity.

        return;

    }

    method void draw(boolean show)
    {
        var int memAddress, loc;
        let loc = (ypos * 512) + xpos; // 32*16 = 512
		let memAddress = 16384 + loc;

        if (show)
        {
            do Memory.poke(memAddress + 0, -1);
            do Memory.poke(memAddress + 32, -32767);
            do Memory.poke(memAddress + 64, -385);
            do Memory.poke(memAddress + 96, -15805);
            do Memory.poke(memAddress + 128, -9637);
            do Memory.poke(memAddress + 160, -9637);
            do Memory.poke(memAddress + 192, -32189);
            do Memory.poke(memAddress + 224, -385);
            do Memory.poke(memAddress + 256, -32383);
            do Memory.poke(memAddress + 288, -32383);
            do Memory.poke(memAddress + 320, -28663);
            do Memory.poke(memAddress + 352, -24583);
            do Memory.poke(memAddress + 384, -27223);
            do Memory.poke(memAddress + 416, -24583);
            do Memory.poke(memAddress + 448, -32767);
            do Memory.poke(memAddress + 480, -1);
        }
        else //clear the sprite
        {
            do Memory.poke(memAddress + 0, 0);
            do Memory.poke(memAddress + 32, 0);
            do Memory.poke(memAddress + 64, 0);
            do Memory.poke(memAddress + 96, 0);
            do Memory.poke(memAddress + 128, 0);
            do Memory.poke(memAddress + 160, 0);
            do Memory.poke(memAddress + 192, 0);
            do Memory.poke(memAddress + 224, 0);
            do Memory.poke(memAddress + 256, 0);
            do Memory.poke(memAddress + 288, 0);
            do Memory.poke(memAddress + 320, 0);
            do Memory.poke(memAddress + 352, 0);
            do Memory.poke(memAddress + 384, 0);
            do Memory.poke(memAddress + 416, 0);
            do Memory.poke(memAddress + 448, 0);
            do Memory.poke(memAddress + 480, 0);
        }
		return;
    }
}
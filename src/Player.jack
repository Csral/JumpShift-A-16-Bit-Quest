//todo: implement player class
class Player
{
    static int gravity_direction, uptime, ground_level;
    field int xpos, ypos, jump_height, dash_cooldown, gravity_cooldown; // player's x and y position
    field boolean is_on_surface;
    field Rd rand;
    
    field int timer; //* Timer to update gravity
    field int g_dir, g_n1_count; //* Gravity direction, no. of times gravity went without 1.

    /*
        * 1: down
        * 2: up
        * 3: right
        * 4: left
    */

    constructor Player new(int x, int y)
    {
        let xpos = x;
        let ypos = y;
        let gravity_direction = 1;
        let is_on_surface = true;
        let dash_cooldown = 0; //* Can use dash
        let timer = rand.between(10,60, c_ypos_d() + rand.between(12,22,18) ) + rand.between(10,60, c_ypos_d() + rand.between(22,42,86) ) ;
        let g_dir = 1;
        let g_n1_count = 0;
        let uptime = 0;
        let gravity_cooldown = 0;
        let ground_level = 15;


        return this;
    }

    method int c_xpos_d() {
        return xpos;
    }

    method int c_ypos_d() {
        return ypos;
    }

    method void dispose()
    {
        do Memory.deAlloc(this);
        return;
    }

    method void update(int x, int y) {

        let xpos = x;
        let ypos = y;
        return;

    }

    method void set_jumping_height(int h) {
        let jump_height = h;
        return;
    }

    method boolean is_jumping() {
        return (jump_height>0);
    }

    ///// changed from method to function by rtamanyu /////////////////////
    function void set_gravity_direction(int dir) {

        if ( (dir < 5) & (dir > 0) ) {
            let gravity_direction = dir;
        }

        if (dir = 1) {
            let ground_level = 15;
        } else {
            if (dir = 2) {
                let ground_level = 0;
            } else {
                if (dir = 3) {
                    let ground_level = 31;
                } else {
                    if (dir = 4) {
                        let ground_level = 0;
                    }
                }
            }
        }

        return;

    }

    function int get_gravity_direction() {
        return gravity_direction;
    }
    // I change it so that it can be used in other classes
    ///////////////////////////////////////////////////////////

    method void enforce_gravity() {

        var int looper;

        if (gravity_direction = 1) {

            let looper = ground_level - ypos; //* How high is the player and drop him per 200 ms.

            if (looper > 0) {

                do draw(false);
                do update(xpos, ypos+1);
                do draw(true);

                do Sys.wait(20);

                let looper = ground_level - ypos;
                let is_on_surface = false;

            } else {
                let is_on_surface = true;
            }

        } else {
            if (gravity_direction = 2) {

                let looper = ypos - ground_level; //* How high is the player and drop him per 200 ms.

                if (looper > 0) {

                    do draw(false);
                    do update(xpos, ypos-1);
                    do draw(true);

                    do Sys.wait(20);

                    let looper = ypos - ground_level;

                }
            
            } else {
                
                if (gravity_direction = 3) {

                    let looper = ground_level - xpos; //* How high is the player and drop him per 200 ms.

                    if (looper > 0) {

                        do draw(false);
                        do update(xpos+1, ypos);
                        do draw(true);

                        do Sys.wait(20);

                        let looper = ground_level - xpos;

                    }

                } else { //* Assumes 4 by default unless there is some fault in code

                    let looper = xpos - ground_level; //* How high is the player and drop him per 200 ms.

                    if (looper > 0) {

                        do draw(false);
                        do update(xpos-1, ypos);
                        do draw(true);

                        do Sys.wait(20);

                        let looper = xpos - ground_level;

                    }

                }

            }
        }

        return;
    }


    method boolean on_ground() {

        var boolean result;

        if (gravity_direction = 1) {
            let result = (ypos = ground_level);  // Store comparison result
        } else {

            if ( gravity_direction = 2) {
                let result = (ypos = ground_level);
            } else {

                if (gravity_direction = 3) {
                    let result = (xpos = ground_level);  // Store comparison result
                } else {
                    if (gravity_direction = 4) {
                        let result = (xpos = ground_level);
                    }
                }
            }

        }

        return result;

    }

    method void collision() { //* Invoked at every jump

        /*
            
            * Where do i get platform coords?

        */

        var int under; //* address of under median

        if (gravity_direction = 1) {

            //* Median is xpos + 1 / 2.
            if (ypos < 15) {
                let under = ( 16384 + ( (ypos) * 512) + ( xpos + 1 ) ) + 512;

                if (GameController.getIsDay()) {

                    if (~(Memory.peek(under) = 0)) {

                        let ground_level = ypos;
                        let is_on_surface = true;
                        return;
                    
                    } else {
                        let ground_level = 15;
                    }

                } else {
                    
                    if ((Memory.peek(under) = 0)) {

                        let ground_level = ypos;
                        let is_on_surface = true;
                        return;
                    
                    } else {
                        let ground_level = 15;
                    }

                }
            }

        } else {

            if (gravity_direction = 2) {

                if (ypos > 0) {
                    let under = ( 16384 + ( (ypos) * 512) + ( xpos + 1 ) ) - 512;

                    if (GameController.getIsDay()) {

                        if (~(Memory.peek(under) = 0)) {

                            let ground_level = ypos;
                            let is_on_surface = true;
                            return;
                        
                        } else {
                            let ground_level = 0;
                        }

                    } else {

                        if ((Memory.peek(under) = 0)) {

                            let ground_level = ypos;
                            let is_on_surface = true;
                            return;
                        
                        } else {
                            let ground_level = 0;
                        }

                    }
                }

            } else {

                if (gravity_direction = 3) {

                    if (xpos < 31) {
                        let under = ( 16384 + ( (ypos) * 512) + ( xpos ) ) + 257;

                        if (GameController.getIsDay()) {

                            if (~(Memory.peek(under) = 0)) {
                                let ground_level = xpos;
                                let is_on_surface = true;
                                return;
                            
                            } else {
                                let ground_level = 31;
                            }

                        } else {

                            if ((Memory.peek(under) = 0)) {
                                let ground_level = xpos;
                                let is_on_surface = true;
                                return;
                            
                            } else {
                                let ground_level = 31;
                            }

                        }
                    }

                } else {

                    if (gravity_direction = 4) {

                        if (xpos > 0) {
                            let under = ( 16384 + ( (ypos) * 512) + ( xpos ) ) - 257;

                            if (GameController.getIsDay()) {

                                if (~(Memory.peek(under) = 0)) {
                                    let ground_level = xpos;
                                    let is_on_surface = true;
                                    return;
                                
                                } else {
                                    let ground_level = 0;
                                }

                            } else {
                                if ((Memory.peek(under) = 0)) {
                                    let ground_level = xpos;
                                    let is_on_surface = true;
                                    return;
                                
                                } else {
                                    let ground_level = 0;
                                }
                            }
                        }

                    }

                }

            }

        }

        return;

    }

    method boolean has_surface() {

        if (on_ground()) {
            return true;
        } else {
            if (jump_height > 0) {
                return false;
            } else {
                //* Assumes collision system to handle everything!
                return is_on_surface;
            }
        }
        
    }

    function int get_time() {
        return uptime;
    }

    method boolean has_gravity_cooldown() {
        return (gravity_cooldown > 0);
    }

    method void set_gravity_cooldown() {

        let gravity_cooldown = 10200;
        return;
    }

    method void stimulate_time() {

        /*

            * Game controller calls this function every time it loops.
            * Each loop has a delay of 50 ms.
            * 1000 ms = 1s.
            * So 20 loop rotations of game controller = 1 second irl.
            * So for 10 seconds cooldown, 10000 ms should become 0 in 200 rotation.
            * So each rotation should cut out 10000/200 => 100/2 => 50 ms.

        */

        /* 

            * Randomly change gravity
            * At a randomly generated time

        */

        if (uptime > 13000) {
            let uptime = 9;
        }

        let uptime = uptime + 1;

        if (timer = 0) {
            let timer = rand.between(10,60, c_ypos_d() + rand.between(12,22,18) ) + rand.between(10,60, c_ypos_d() + rand.between(22,42,86) ) ;
            let g_dir = rand.between(1,4, c_xpos_d());

            if (~(g_dir = 1)) {
                if (g_n1_count > 4) {
                    let g_dir = 1;
                    let g_n1_count = 0;
                } else {
                    let g_n1_count = g_n1_count + 1;
                }
            } else {
                let g_n1_count = 0;
            }
            do Player.set_gravity_direction(g_dir);
        } else {
            let timer = timer - 1;
        }

        if (~on_ground()) {
            if (~is_jumping()) {
                do enforce_gravity();
            } else {
                do jump();
            }

        }

        /*

            * Cooldown guide: (precision errors of 0-1)
            * Dash: 10-11 secs (200 rotations)
            * Gravity Control: 30-31 secs (600 rotations) -> (10200 ; -17 per rotation)

        */

        if (dash_cooldown > 0) {
            let dash_cooldown = dash_cooldown - 50;
        }

        
        if (gravity_cooldown > 0) {
            let gravity_cooldown = gravity_cooldown - 17;
        }

        do collision();

        return;

    }

    method void dash() {

        if (dash_cooldown = 0) {

            let dash_cooldown = 10000; //10 secs.

            do draw(false); //* remove player's current position
            
            if (gravity_direction = 1) {
                if (xpos+5 > 31) {let xpos = 19;}

                do update(xpos+5,ypos);
            } else {
                if (gravity_direction = 2) {

                    if (xpos+5 > 31) {let xpos = 19;}

                    do update(xpos+5,ypos);
                } else {
                    if (gravity_direction = 3) {
                        if (ypos-5 < 0) {let ypos = 19;}
                        do update(xpos,ypos-5);
                    } else {
                        if (gravity_direction = 4) {
                            if (ypos-5 < 0) {let ypos = 19;}
                            do update(xpos+5,ypos-5);
                        }
                    }
                }
            }

            do draw(true);

        }

        return;
        
    }

    method void summon_ground_ability() {

        return;

    }

    method void jump() {

        if ((jump_height > 0)) {

            /*

                * Clears current player
                * Updates location
                * Draws player at updated location

            */

            do draw(false);

            if (gravity_direction = 1) {
                do update(xpos, ypos-1); //* Update xpos and ypos.
            } else {
                if (gravity_direction = 2) {
                    do update(xpos, ypos+1); //* Update xpos and ypos.
                } else {
                    if (gravity_direction = 3) {
                        do update(xpos-1, ypos); //* Update xpos and ypos.
                    } else {
                        if (gravity_direction = 4) {
                            do update(xpos+1, ypos); //* Update xpos and ypos.
                        }
                    }
                }
            }

            do draw(true);

            do Sys.wait(20); //* Wait 1s before continuing. Adjust for animation
            let jump_height = jump_height - 1; //* Adjust 1 for smoother/rougher animation

        }

        //* Falling down will be handled by enforce gravity.

        return;

    }

    method void draw(boolean show)
    {
        var int memAddress, loc;
        let loc = (ypos * 512) + xpos; // 32*16 = 512
		let memAddress = 16384 + loc;

        if (show)
        {
            do Memory.poke(memAddress + 0, 0);
            do Memory.poke(memAddress + 32, 4064);
            do Memory.poke(memAddress + 64, 4064);
            do Memory.poke(memAddress + 96, 1760);
            do Memory.poke(memAddress + 128, 1376);
            do Memory.poke(memAddress + 160, 1728);
            do Memory.poke(memAddress + 192, 904);
            do Memory.poke(memAddress + 224, 1736);
            do Memory.poke(memAddress + 256, 7928);
            do Memory.poke(memAddress + 288, 5184);
            do Memory.poke(memAddress + 320, 5824);
            do Memory.poke(memAddress + 352, 1984);
            do Memory.poke(memAddress + 384, 896);
            do Memory.poke(memAddress + 416, 896);
            do Memory.poke(memAddress + 448, 1728);
            do Memory.poke(memAddress + 480, 1088); //* This filled by 256 and rest by 0 to get median point.
            
            //* Median: 16384 + (ypos * 512) + xpos + 480
            
        }
        else //clear the sprite
        {
            if (GameController.getIsDay()) {
                do Memory.poke(memAddress + 0, 0);
                do Memory.poke(memAddress + 32, 0);
                do Memory.poke(memAddress + 64, 0);
                do Memory.poke(memAddress + 96, 0);
                do Memory.poke(memAddress + 128, 0);
                do Memory.poke(memAddress + 160, 0);
                do Memory.poke(memAddress + 192, 0);
                do Memory.poke(memAddress + 224, 0);
                do Memory.poke(memAddress + 256, 0);
                do Memory.poke(memAddress + 288, 0);
                do Memory.poke(memAddress + 320, 0);
                do Memory.poke(memAddress + 352, 0);
                do Memory.poke(memAddress + 384, 0);
                do Memory.poke(memAddress + 416, 0);
                do Memory.poke(memAddress + 448, 0);
                do Memory.poke(memAddress + 480, 0);
            } else {
                do Memory.poke(memAddress + 0, -1);
                do Memory.poke(memAddress + 32, -1);
                do Memory.poke(memAddress + 64, -1);
                do Memory.poke(memAddress + 96, -1);
                do Memory.poke(memAddress + 128, -1);
                do Memory.poke(memAddress + 160, -1);
                do Memory.poke(memAddress + 192, -1);
                do Memory.poke(memAddress + 224, -1);
                do Memory.poke(memAddress + 256, -1);
                do Memory.poke(memAddress + 288, -1);
                do Memory.poke(memAddress + 320, -1);
                do Memory.poke(memAddress + 352, -1);
                do Memory.poke(memAddress + 384, -1);
                do Memory.poke(memAddress + 416, -1);
                do Memory.poke(memAddress + 448, -1);
                do Memory.poke(memAddress + 480, -1);
            }
        }

        // negation:

        /*

            method void draw(int location) {
                let memAddress = 16384 + location;
                do Memory.poke(memAddress + 0, -1);
                do Memory.poke(memAddress + 32, -4065);
                do Memory.poke(memAddress + 64, -4065);
                do Memory.poke(memAddress + 96, -1761);
                do Memory.poke(memAddress + 128, -1377);
                do Memory.poke(memAddress + 160, -1729);
                do Memory.poke(memAddress + 192, -905);
                do Memory.poke(memAddress + 224, -1737);
                do Memory.poke(memAddress + 256, -7929);
                do Memory.poke(memAddress + 288, -5185);
                do Memory.poke(memAddress + 320, -5825);
                do Memory.poke(memAddress + 352, -1985);
                do Memory.poke(memAddress + 384, -897);
                do Memory.poke(memAddress + 416, -897);
                do Memory.poke(memAddress + 448, -1729);
                do Memory.poke(memAddress + 480, -1089);
                return;
            }

        */

		return;
    }
}
//note: A class must have atleast one field var, otherwisw it gives 'Allocated memory size must be postivie' error
//important: screen size: 512x256
//important: axis - x: 0-31, y: 0-15
//important: dir - 1 - forward, 2 - backward, 3 - up, 4 - down

//note: if println() not displaying, then try commenting Screen.clearScreen() in Platform.draw() method
class GameController
{
   static int moveDir;       // direction of the motion
   static int dispDir;       // direction in which the upcoming platforms must be displayed
   static int delay;           //wait time between each frame
   static boolean isDay;   // true if the game is in day mode

   field boolean exit;       // true when the game is over
   field int spawnDiff;      // difference between the y position of the current platform and the next platform
   field int baseHeight;     // buffer height to be maintained between the platform and the screen boundary when forward or backward
   field int baseWidth;     // buffer width to be maintained between the platform and the screen boundary when up or down

   field int dayNightTimer;  // timer to switch between day and night mode
   field int dayNightDelay;  // delay between each switch between day and night mode   


   constructor GameController new()
   {
      let delay = 50;
      let moveDir = 1;
      let dispDir = 1;
      let spawnDiff = 2;
      let baseHeight = 3;
      let baseWidth = 5;
      let isDay = true;
      let dayNightDelay = 15;
      let dayNightTimer = dayNightDelay;
      return this;
   }

   function boolean getIsDay()
   {
      return isDay;
   }

   method void setDelay(int d)
   {
      let delay = d;
      return;
   }

   method int random(int x, int y)
   {
      var Rd rd;
      // do Random.seed(Memory.peek(Random.between(16384, 24577) + Memory.peek(0)));
      // do Random.seed(Memory.peek(rd.between(16384, 24577, 0) + Memory.peek(0)));
      // return Random.between(x, y);
      return rd.between(x, y, 0);
   }

   method void start()
   {
      var Platform platform;
      var Player player;
      var Rd rand;
      var char key;
      var int timer; //* Timer to update gravity
      var int g_dir, g_n1_count; //* Gravity direction, no. of times gravity went without 1.

      ///note: for testing
      // do Screen.setColor(true);
      // do Screen.drawRectangle(0,0,511,255);
      //////////////
      //TODO: implement the start config of platform and player
      let platform = Platform.new(15, 15, 3, dispDir, moveDir);
      let player = Player.new(19, 15);
      do player.draw(true);
      do platform.draw(true, false);

      let timer = rand.between(10,60, player.c_ypos_d() + rand.between(12,22,18) ) + rand.between(10,60, player.c_ypos_d() + rand.between(22,42,86) ) ;
      let g_dir = 1;
      
      let g_n1_count = 0;

      while (~exit)
      {

         // waits for a key to be pressed.
         // update screen and move platform

         while ((key = 0) & (~exit)) {

            // Switch between day and night mode
            if (dayNightTimer = 0) 
            {
               let dayNightTimer = dayNightDelay;
               let isDay = ~isDay;
               if (~isDay) {
                  do Screen.setColor(true);
               } else {
                  do Screen.setColor(false);
               }
               do Screen.drawRectangle(0,0,511,255);
            } 
            else {
               let dayNightTimer = dayNightTimer - 1;
            }

            /* 
               * Randomly change gravity
               * At a randomly generated time
            */
            if (timer = 0) {
               let timer = rand.between(10,60, player.c_ypos_d() + rand.between(12,22,18) ) + rand.between(10,60, player.c_ypos_d() + rand.between(22,42,86) ) ;
               let g_dir = rand.between(1,4, player.c_xpos_d());

               if (~(g_dir = 1)) {
                  if (g_n1_count > 4) {
                     let g_dir = 1;
                     let g_n1_count = 0;
                  } else {
                     let g_n1_count = g_n1_count + 1;
                  }
               } else {
                  let g_n1_count = 0;
               }
               
               do Output.printInt(g_dir);
               // do player.set_gravity_direction(g_dir);
               do Player.set_gravity_direction(g_dir);
            } else {
               let timer = timer - 1;
            }

            //* Decrease dash cooldown

            do player.stimulate_time();

            // Handle user inputs

            let key = Keyboard.keyPressed();

            if (~player.on_ground()) {
               if (~player.is_jumping()) {
                  do player.enforce_gravity();
               } else {
                  do player.jump();
               }

            }

            do handlePlatform();
            do player.draw(true);
            do Sys.wait(50);
         }
         
         if ( key = 32 & ~player.is_jumping() ) // jump when space is pressed and player is not already jumping
         {
            // todo: perform player jump when space key is pressed
            do player.set_jumping_height(5);
            do player.jump();
         }
         else 
         {
            if (key = 140) { let exit = true; } // exit when esc is pressed
            else {
               if (key = 70) {
                  //* Key: F

                  do player.dash();

               }
            }
         }

         // Waits for the key to be released.
         // update screen and move platform
         while ((~(key = 0)) & (~exit)) {
               let key = Keyboard.keyPressed();
               do handlePlatform();
               do Sys.wait(50);
         }
      }

      // todo: implement game over screen
      if (exit) {
         do Output.moveCursor(10,27);
         do Output.printString("Game Over");
      }

      return;
   }

   //note: uncommment it if there is change in gravity direction config in Player class
   // // get the current direction of the platform from the gravity direction
   // method int getCurDirFromGravity(int g_dir)
   // {
   //    if (g_dir = 1)
   //    {
   //       return 1;
   //    }
   //    else
   //    {
   //       if (g_dir = 2)
   //       {
   //          return 2;
   //       }
   //       else
   //       {
   //          if (g_dir = 3)
   //          {
   //             return 3;
   //          }
   //          else
   //          {
   //             return 4;
   //          }
   //       }
   //    }
   // }

   // control the movement and procedural generation of the platform
   method void handlePlatform()
   {
      var Platform curPlatform, nextplatform, p1, p2;
      var int x,y,l,rand,curDir;

      let curDir = Player.get_gravity_direction(); //get the current direction of the gravity

      // change the direction of the platform if the gravity direction has changed
      if (~(moveDir = curDir))   
      {
         do Platform.disposeAll();

         //render BG acoording to the day/night mode
         if (~isDay)
         {
            do Screen.setColor(true);       
         }
         else
         {
            do Screen.setColor(false);
         }
         do Screen.drawRectangle(0,0,511,255);

         let moveDir = curDir;
         let dispDir = curDir;

         // construct predefinied initial platforms based on the direction of the gravity
         if (curDir = 1)
         {
            let p1 =  Platform.new(15, 15, 5, dispDir, moveDir);            
            let p2 = Platform.new(22, 15, 5, dispDir, moveDir);         
         }
         else
         {
            if (curDir = 2)
            {
               let p1 =  Platform.new(15, 15, 5, dispDir, moveDir);            
               let p2 = Platform.new(7, 15, 5, dispDir, moveDir);         
            }
            else
            {
               if (curDir = 3)
               {
                  let p1 =  Platform.new(15, 8, 5, dispDir, moveDir);            
                  let p2 = Platform.new(15, 15, 5, dispDir, moveDir);         
               }
               else
               {
                  let p1 =  Platform.new(15, 2, 5, dispDir, moveDir);
                  let p2 = Platform.new(15, 10, 5, dispDir, moveDir);
               }
            }
         }
         
         // draw those initial platforms
         do p1.draw(true, false);
         do p2.draw(true, false);
         return;
      }
      
      let curPlatform = Platform.getFirst();
      
      while(curPlatform.hasNext()) //update the position of all the platforms except last
      {
         do curPlatform.move();
         let curPlatform = curPlatform.getNext();
      }

      do curPlatform.move(); // update the position of the last platform

      //note: uncomment below if individual platform testing is required
      // return;
      
      // generate a new platform if the last platform has fully entered the scene
      if(curPlatform.hasFullyEnteredScene()) 
      {
         let rand = Random.between(0, 10); //0-4 -> spawn down or spawn left, 5-9 -> spawn up or spawn right
         let l = Random.between(3, 8);
         if (moveDir < 3) //if the direction is forward or backward (0-4 -> spawn down, 5-9 -> spawn up)
         {          
            if (rand < 5)
            {
               if((curPlatform.getY() + spawnDiff) > (15 - baseHeight))
               {
                  let y = curPlatform.getY() - spawnDiff;
               }
               else
               {
                  let y = curPlatform.getY() + spawnDiff;
               }
            }
            else
            {
               if((curPlatform.getY() - spawnDiff) < 2)
               {
                  let y = curPlatform.getY() + spawnDiff;
               }
               else
               {
                  let y = curPlatform.getY() - spawnDiff;
               }
            }           

            if (moveDir = 1)
            {
               let x = 32;
            }
            else
            {
               let x = -1 - l;
            }
         }
         else //if the direction is up or down (0-4 -> spawn left, 5-9 -> spawn right)
         {
            if (rand < 5)
               {
                  if((curPlatform.getX() - spawnDiff) < 3)
                  {
                     let x = curPlatform.getX() + spawnDiff;
                  }
                  else
                  {
                     let x = curPlatform.getX() - spawnDiff;
                  }
               }
               else
               {
                  if((curPlatform.getX() + spawnDiff) > (29 - baseWidth))
                  {
                     let x = curPlatform.getX() - spawnDiff;
                  }
                  else
                  {
                     let x = curPlatform.getX() + spawnDiff;
                  }
               }           

               if (moveDir = 3)
               {
                  let y = 16;
               }
               else
               {
                  let y = -1 - l;
               }
         }

         //do Output.printInt(2);
         do Platform.new(x, y, l, dispDir, moveDir);   
      }

      let curPlatform = Platform.getFirst();

      // Remove the platforms that has exited the screen
      if(curPlatform.hasExittedScreen())
      {
         //do Output.printInt(1);
         do curPlatform.dispose();
      }

      return;
   }

   method void dispose()
   {
      do Memory.deAlloc(this);
      return;
   }
}